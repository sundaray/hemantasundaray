---
title: How to Implement Google Sign-In in Next.js with Supabase Auth
description: "Learn how to integrate Google Sign-in functionality into your Next.js app using Supabase Auth."
author: Hemanta Sundaray
publishedAt: 2024-07-18
tags: ["Supabase Auth", "Next.js", "Google Sign-In", "Authentication"]
published: false
---

import Image from "next/image"

import { BlogPostLayout } from "@/components/blog-post-layout"
import { Note } from "@/components/note"
import Avatar from "@/app/blog/images/avatar.jpg"

<BlogPostLayout frontmatter={frontmatter}>

If you want to integrate Sign in with Google in your Next.js app using Supabase Auth, you're in the right place. This comprehensive guide covers everything you need, from creating a Supabase project and configuring Google Cloud for OAuth to setting up your Next.js project and implementing robust authentication and authorization logic.

In this guide, you'll learn how to:

- Set up a Supabase project and configure Google Cloud for OAuth
- Implement Google Sign-in in your Next.js application
- Access user information inside both client and server components
- Protect routes using middleware
- Assign roles to users using Supabase auth hooks
- Create and manage a users table in the public schema

Let's get started!

## Create a Supabase Project

- Go to [supabase.com/dashboard/projects](https://supabase.com/dashboard/projects) (sign in if you have an account, or create one if you don't).
- Click on **New project**.
- Give your project a name, choose a database password, select a region, and then click on **Create new project**.
- The project setup may take a minute or two to complete. Once the setup is finished, scroll down the page to find the **Project API** and **JWT Settings** sections.

  From the **Project API** section, copy the **Project URL** and **API Key**. From the **JWT Settings** section, copy the **JWT Secret**. Save these three values somewhere safe - we'll need them later in our setup process.

  You'll notice that the **API Key** is tagged with **anon** and **public**. This **anon** key (short for anonymous) is a public key that's safe to use in a browser, but _only if you've enabled RLS (row-level security) for your tables and configured appropriate policies_.

<Note title="Note">
**When you create a Supabase project, Supabase automatically deploys an instance of the Auth API server and injects your database with the required auth schema**. This Auth API server is responsible for:
 
 - Validating, issuing, and refreshing JSON Web Tokens (JWTs).
 - Serving as an intermediary between your app and the auth information in the database.
 - Communicating with external providers for Social Login and SSO (Single Sign-On).

To view the auth schema in the Supabase dashboard:

- Click on **Database** in the sidebar navigation.
- You'll see a dropdown menu to select a schema. Choose **auth** from this dropdown.
- You'll notice a list of tables appears. These are the tables that store user information, sessions, identities and other authentication-related data

It's crucial to understand that **the auth schema in Supabase is managed internally and is read-only through the dashboard**. This means that your application code cannot directly access or modify the auth schema tables.

But what if you want to keep track of user information, for example, to display a list of users on a page accessible only to administrators? In such cases, you must create your own user table in the public schema, which I'll guide you through later in this guide.

You can then link the **public.users** table to the **auth.users** table using the users' UUIDs as foreign keys. This approach allows you to store and manage user data while maintaining the integrity and security of Supabase's core authentication system.

</Note>

## Configure Google Cloud for OAuth

- Go to the [Google Cloud Console](console.cloud.google.com).
- On the main navigation bar at the top, to the left of the search input, there is a dropdown menu. Click on the dropdown menu to open a pop-up window with all of your projects listed. In the pop-up window, click on **NEW PROJECT**.
- Enter a project name and click **CREATE**. It’ll take half a minute or so to create the project. Once the project is created, select it.
- Navigate to **APIs & Services** > **OAuth consent screen**.

### OAuth consent screen

- Choose **External** as the user type (this will make your project accessible to anyone with a Google account) and click **CREATE**.
- Under **App information**, enter the **App name** and the **user support email**. Under **Authorized domains**, enter the Supabase **Project URL** (which you had copied earlier). Under **Developer contact information**, enter your email address. Then click **SAVE AND CONTINUE**.

  An authorized domain is a domain that you explicitly allow to use your OAuth credentials. By entering the Supabase Project URL as an authorized domain, you ensure that only requests originating from the Supabase Project URL can use your OAuth Client ID and Client Secret to authenticate users. This helps prevent unauthorized use of your OAuth credentials.

#### Scopes

On the **Scopes** page, you'll see the following information:

- **Non-sensitive scopes**: Permissions that your app requests which are generally safe and don't require extensive review by Google.
- **Sensitive scopes**: Permissions that request access to more private user data.
- **Restricted scopes**: Permissions that request access to highly sensitive user data.

If your app doesn't require access to sensitive or restricted data, you can proceed without adding any scopes. Click **SAVE AND CONTINUE**.

#### Test users

On the **Test users** page, you'll see the following information:

- **Test users**: While publishing status is set to **Testing**, only test users are able to access the app. Allowed user cap prior to app verification is 100, and is counted over the entire lifetime of the app.

If you don't need to add any specific test users at this point, you can proceed by clicking **SAVE AND CONTINUE**.

#### Summary

On the **Summary** page, review the information to ensure everything is correct. Click **BACK TO DASHBOARD**.

### OAuth Client ID

Navigate to **APIs & Services** > **Credentials**. Click on **Create Credentials** and select **OAuth client ID**.

On the **Create OAuth Client ID** page, follow the steps below to fill out the fields:

- **Application Type**: Select Web application.
- **Name**: Enter a name for your OAuth 2.0 client. This name is only used to identify the client in the console and will not be shown to end users.
- **Authorized JavaScript origins**: Add the origins from which your app is allowed to access the Google APIs. As we are developing locally, add `http://localhost:3000`.
- **Authorized Redirect URIs**: Add the **Callback URL** from your Supabase dashboard.
- Click **CREATE** to generate your **Client ID** and **Client Secret**. Copy both the **Client ID** and the **Client Secret** and save them somewhere safe; we will need them in the next step.

<Note title="How to locate the Callback URL (OAuth) in Supabase dashboard">

To find the Callback URL in your Supabase dashboard, follow these steps:

- On the sidebar navigation, click **Authentication**.
- Under the **CONFIGURATION** section, click **Providers**.
- Click **Google** in the list of providers. Scroll down slightly, and you'll see the **Callback URL**
  displayed.

</Note>

- Return to your Supabase dashboard. Navigate to **Authentication** > **Providers**.
- Find **Google** in the list and click on it.
- Toggle **Enable Sign In with Google** to on.
- Enter the **Client ID** and **Client Secret** you obtained from Google Cloud.
- Click **Save** to apply the changes

## Set up a Next.js Project

Create a Next.js project by using `create-next-app`:

```sh
npx create-next-app@latest supabase-auth-nextjs-demo
```

**Note**: I’ve named the project `supabase-auth-nextjs-demo`, but you can choose any name you prefer.

Once the project is created, navigate to the project directory. Once the project is created, navigate to the project directory. Once the project is created, navigate to the project directory:

Install shadcn/ui:
shadcn/ui is a collection of re-usable components that we'll use in our project. To set it up, run the following command:

```sh
npx shadcn-ui@latest init
```

Follow the prompts to configure shadcn/ui according to your preferences.

We'll be using the `Button`, `Dropdown`, and `Toast` components. Install them with these commands:

```sh
npx shadcn-ui@latest add button
npx shadcn-ui@latest add dropdown-menu
npx shadcn-ui@latest add toast
```

we'll use Lucide icons in our project. Install it with npm:

```sh
npm install lucide-react
```

Install Supabase packages:
We'll need the Supabase client library to interact with our Supabase backend:

```sh
npm install @supabase/supabase-js @supabase/ssr
```

### Configure Environment Variables

Create a .env.local file in the root directory of your project, and add the following environment variables:

```sh
NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_JWT_SECRET=your_supabase_jwt_secret
```

Replace your_supabase_project_url, your_supabase_anon_key, and your_supabase_jwt_secret with the values you copied earlier from your Supabase project.

If you need to find these values again, navigate to the "Project Settings" in your Supabase dashboard. Under the CONFIGURATION section, click "API". Here you'll find the Project URL, the API Key and the JWT Secret.

### Set up Supabase Clients

We need to set up two different Supabase clients.

Create a new folder named `supabase` inside the `lib` folder of your project. Inside the `supabase` folder, create two files: `client.ts` and `server.ts`.

In `client.ts`, add the following code:

```tsx title="@/lib/supabase/client.ts"
import { createBrowserClient } from "@supabase/ssr"

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

In `server.ts`, add the following code:

```tsx title="@/lib/supabase/server.ts"
import { cookies } from "next/headers"
import { createServerClient, type CookieOptions } from "@supabase/ssr"

export function createClient() {
  const cookieStore = cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll: async () => {
          return cookieStore.getAll().map((cookie) => ({
            name: cookie.name,
            value: cookie.value,
          }))
        },
        setAll: async (
          cookiesToSet: {
            name: string
            value: string
            options: CookieOptions
          }[]
        ) => {
          cookiesToSet.forEach((cookie) => {
            cookieStore.set(cookie.name, cookie.value, cookie.options)
          })
        },
      },
    }
  )
}
```

You might be wondering why we need two separate client files. The reason is that we use different methods to access Supabase depending on where we're making the call:

- The `createClient` function in `client.ts` is used to access Supabase inside client components.
- The `createClient` function in `server.ts` is used to access Supabase inside server components, server actions, and route handlers.

### Set up middleware

Middleware in Next.js allows you to run code before a request is completed. In our case, we'll use it to handle authentication and authorization. Let's set it up:

#### Root middleware

First, create a middleware.ts file at the root of your project:

```ts title="@/middleware.ts"
import { type NextRequest } from "next/server"

import { updateSession } from "@/lib/supabase/middleware"

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: ["/protected", "/login", "/admin/:path*"],
}
```

The matcher array specifies which routes the middleware should run on. In this case:

- **/protected**: Ensures only authenticated users can access this route
- **/login**: Handles redirects for already authenticated users
- **/admin/:path\***: Protects all routes under /admin, ensuring only users with admin roles can access them

#### Supabase middleware

Now, create a `middleware.ts` file inside the `/lib/supabase` folder:

```ts title="@/lib/supabase/middleware.ts"
import { NextResponse, type NextRequest } from "next/server"
import { createServerClient } from "@supabase/ssr"

import { getUserRole } from "@/lib/supabase/get-user-role-server"

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  // Create a Supabase client for server-side operations
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        // Get all cookies from the request
        getAll() {
          return request.cookies.getAll()
        },
        // Set cookies in both the request and response
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            request.cookies.set(name, value)
          )
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // Get the current user from Supabase
  const {
    data: { user },
  } = await supabase.auth.getUser()

  // Get the user's role using the custom getUserRole function
  const role = await getUserRole()

  // Redirect non-admin users trying to access admin pages to the home page
  if (
    user &&
    role !== "admin" &&
    request.nextUrl.pathname.startsWith("/admin")
  ) {
    const url = request.nextUrl.clone()
    url.pathname = "/"
    return NextResponse.redirect(url)
  }

  // Redirect unauthenticated users to login page
  if (
    !user &&
    !request.nextUrl.pathname.startsWith("/login") &&
    !request.nextUrl.pathname.startsWith("/auth")
  ) {
    const url = request.nextUrl.clone()
    url.pathname = "/login"
    url.searchParams.set("next", request.nextUrl.pathname)
    return NextResponse.redirect(url)
  }

  // Redirect authenticated users attempting to access the login page to the home page
  if (user && request.nextUrl.pathname.startsWith("/login")) {
    const url = request.nextUrl.clone()
    url.pathname = "/"
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}
```

This middleware file handles several key aspects of our authentication flow:

- It creates a Supabase client for server-side operations.
- It checks the user's authentication status and role.
- It manages redirects based on the user's authentication status and the route they're trying to access.

Here's a breakdown of the redirect logic:

- If an unauthenticated user tries to access any page mentioned in the matcher array, they are redirected to the login page. While redirecting, we also set the next parameter. This next parameter is crucial because it stores the URL of the page the user was trying to access. After successful authentication, we can use this parameter to redirect the user back to their intended destination, providing a seamless user experience.
- If a signed-in user tries to access the sign-in page, we redirect them to the home page. This is because the user is already authenticated, so they don't need to go to the sign-in page anymore. This prevents unnecessary authentication attempts and improves the user flow.
- Finally, if a signed-in user is trying to access an admin page but does not have the admin role, they are redirected to the home page. This ensures that only users with the appropriate permissions can access sensitive admin areas of the application.

By implementing these redirects, we maintain proper access control throughout the application, ensuring users are always directed to the appropriate pages based on their authentication status and roles.

### Assign roles to users

After setting up our middleware, we need to address how roles are assigned to users. This is where the concept of custom claims comes into play. Custom claims are essentially special attributes that we can attach to a user. In our case, we want to attach a role, so that we can use this role to control access to special areas of our application. These custom claims are implemented using a Custom Access Token Auth Hook.
Auth hooks are Postgres functions that we can use to alter the default Supabase Auth flow. We'll use the following function to add a role field to the JWT:

```sql
create or replace function public.set_user_role(event jsonb)
returns jsonb
language plpgsql
as $$
declare
  claims jsonb;
  user_email text;
begin
  -- Log the entire event object
  RAISE LOG 'Full event object: %', event;

  -- Get the user's email
  user_email := event->>'email';

  -- Log the user's email
  RAISE LOG 'User email: %', user_email;

  claims := coalesce(event->'claims', '{}'::jsonb);

  -- Check if 'app_metadata' exists in claims
  if jsonb_typeof(claims->'app_metadata') is null then
    claims := jsonb_set(claims, '{app_metadata}', '{}');
  end if;

  -- Set a claim of 'admin' if the email matches, otherwise 'regular'
  if user_email = 'rawgrittt@gmail.com' then
    claims := jsonb_set(claims, '{app_metadata, role}', '"admin"');
    -- Log the role being set
    RAISE LOG 'Setting role to admin for email: %', user_email;
  else
    claims := jsonb_set(claims, '{app_metadata, role}', '"regular"');
    -- Log the role being set
    RAISE LOG 'Setting role to regular for email: %', user_email;
  end if;

  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);

  -- Log the final event object
  RAISE LOG 'Final event object: %', event;

  return event;
end;
$$;

-- Set permissions for the function
grant usage on schema public to supabase_auth_admin;
grant execute on function public.set_user_role to supabase_auth_admin;
revoke execute on function public.set_user_role from authenticated, anon, public;
```

This function does the following:

- It checks the user's email address.
- If the email is 'rawgrittt@gmail.com', it sets the role to "admin".
- For all other email addresses, it sets the role to "regular".
- The role is set inside the app_metadata object, which is part of the JWT claims.

We've used RAISE LOG statements throughout the function. These are helpful for debugging purposes, allowing you to study the structure of the event object passed to the function and troubleshoot if any errors occur. You can find these logs in the Supabase dashboard under "Database" > "Logs" > "Postgres Logs".

Notice the last three lines of code in the function above:

These lines are crucial for setting up the correct permissions for our function:

- We grant the supabase_auth_admin role permission to use the public schema.
- We grant the supabase_auth_admin role permission to execute our set_user_role function.
- We revoke execute permissions from the authenticated, anon, and public roles.

The reason for revoking permissions is to enhance security. By default, the public role has access to functions created in the public schema, and both anon and authenticated roles inherit permissions from the public role. By revoking these permissions, we ensure that our role-setting function is not accessible via Supabase Serverless APIs or by regular users. This prevents potential misuse or unauthorized manipulation of user roles.

To implement this function:

- Go to the SQL editor in the Supabase dashboard.
- Paste the entire function (including the permission grants and revokes) into the editor.
- Click "RUN" to create the function and set the permissions.

Finally, to enable the custom claims:

- In the Supabase dashboard, click on "Authentication" in the sidebar navigation.
- Go to "Configuration" > "Hooks".
- Enable "Custom Access token (JWT) Claims hook".
- Select the set_user_role function.

By setting up this hook, Supabase will add the role property to the JWT before releasing it, ensuring that each user's token contains their assigned role.

### Creating Core Components

In a typical app, you'll find a main navigation bar with navigation links and a sign-in button. This is the structure we're going to follow.

We'll create a main navigation bar component with the following links:

- Client
- Server
- Protected
- Admin

These links are carefully planned to cover common authentication and authorization use cases in a Next.js app:

- Accessing signed-in user information on client components
- Accessing signed-in user information on server components
- Protecting routes accessible only to signed-in users
- Protecting routes accessible only to signed-in users with specific roles (e.g., admin)

Let's start by defining our components.

#### MainNav component

Create a file named `main-nav.tsx` in the `components` folder:

```tsx title="@/components/main-nav.tsx"
import { NavItem } from "@/components/nav-item"
import { UserAccountNav } from "@/components/user-account-nav"

export function MainNav() {
  return (
    <nav className="flex h-16 items-center justify-between border px-4">
      <div className="flex space-x-4">
        <NavItem href="/client">Client</NavItem>
        <NavItem href="/server">Server</NavItem>
        <NavItem href="/protected">Protected</NavItem>
        <NavItem href="/admin">Admin</NavItem>
      </div>
      <UserAccountNav />
    </nav>
  )
}
```

NavItem component

Create a file named `nav-item.tsx` in the `components` folder:

```tsx title="@/components/nav-items.tsx"
"use client"

import Link from "next/link"
import { usePathname } from "next/navigation"

import { cn } from "@/lib/utils"

type NavItemProps = {
  href: string
  children: React.ReactNode
}

export function NavItem({ href, children }: NavItemProps) {
  const pathname = usePathname()
  const isActive = pathname === href

  return (
    <Link
      href={href}
      className={cn("text-muted-foreground text-sm", {
        "text-secondary-foreground": isActive,
      })}
    >
      {children}
    </Link>
  )
}
```

UserAccountNav component

Create a file named `user-account-nav.tsx` in the `components` folder:

```tsx title="@/components/user-account-nav.tsx"
import React from "react"
import { FaUser } from "react-icons/fa6"

import { createClient } from "@/lib/supabase/server"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { SignInButton } from "@/components/signin-button"

import { SignOutButton } from "./signout-button"

export async function UserAccountNav() {
  const supabase = createClient()
  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user) {
    return <SignInButton />
  }

  return (
    <div className="w-max space-x-2">
      <DropdownMenu>
        <DropdownMenuTrigger className="flex items-center space-x-1">
          <div className="bg-border grid size-7 place-items-center rounded-full">
            <FaUser className="text-muted-foreground" />
          </div>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <div className="flex items-center justify-start gap-2 p-2">
            <div className="flex flex-col space-y-1 leading-none">
              {user.email && (
                <p className="text-muted-foreground w-[200px] truncate text-sm">
                  {user.email}
                </p>
              )}
            </div>
          </div>
          <DropdownMenuSeparator />
          <DropdownMenuItem className="cursor-pointer">
            <SignOutButton />
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  )
}
```

Here, we check for the presence of a user. If no user is present, we render a `SignInButton` component. If a user is present, we render a user icon. Clicking on the user icon reveals a dropdown with the user's email and a Sign out button.

Note that the `getUser()` method sends a request to the Supabase Auth server every time to revalidate the Auth token.

SignInButton component

Create a file named `signin-button.tsx` in the `components` folder:

```tsx title="@/components/signin-button.tsx"
"use client"

import Link from "next/link"
import { usePathname } from "next/navigation"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export function SignInButton() {
  const pathname = usePathname()

  return pathname !== "/login" ? (
    <Link
      href="/login"
      className={cn(buttonVariants({ variant: "secondary", size: "sm" }))}
    >
      Sign in
    </Link>
  ) : null
}
```

Clicking on the Sign In link takes the user to the login page where we render the `Sign in with Google` button.

SignOutButton component
Create a file named `signout-button.tsx` in the `components` folder:

```tsx title="@/components/signout-button.tsx"
"use client"

import { useRouter } from "next/navigation"

import { createClient } from "@/lib/supabase/client"
import { Button } from "@/components/ui/button"

export function SignOutButton() {
  const supabase = createClient()
  const router = useRouter()

  async function handleLogout() {
    await supabase.auth.signOut()
    router.push("/login")
    router.refresh()
  }

  return (
    <Button className="w-full" onClick={handleLogout}>
      Sign out
    </Button>
  )
}
```

In the `SignOutButton` component, we use the `signOut()` method to sign out the user and then redirect them to the `login` page. We also refresh the page to ensure that the `UserAccountNav` component (which is a server component) accurately renders the authentication state.

## Create Pages

Now that we have our basic components, let's create the pages that will be rendered when we click on the links in the main navigation.

#### Client page

Create a file named `page.tsx` inside the `app/client` folder:

```tsx title="@/app/client/page.tsx"
"use client"

import { useUser } from "@/hooks/use-user"

export default function ClientPage() {
  const { loading, error, user, role } = useUser()

  return (
    <div className="space-y-4">
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p>Error: {error.message}</p>
      ) : (
        <>
          <h1 className="text-lg font-medium">User: {user?.email || "N/A"}</h1>
          <h2 className="text-lg font-medium"> Role: {role || "N/A"}</h2>
        </>
      )}
      <p className="text-muted-foreground">(I am a client component.)</p>
    </div>
  )
}
```

We're using a custom hook in this client component to get the user information. Let's create that hook now.

#### useUser hook

Create a file named `use-user.ts` inside a new `hooks` folder at the project root:

```ts title="@/hooks/use-user.ts"
import { useEffect, useState } from "react"
import { AuthError, Session, User } from "@supabase/supabase-js"
import { jwtDecode } from "jwt-decode"
import type { JwtPayload } from "jwt-decode"

import { createClient } from "@/lib/supabase/client"

type SupabaseJwtPayload = JwtPayload & {
  app_metadata: {
    role: string
  }
}

export function useUser() {
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<AuthError | null>(null)
  const [role, setRole] = useState<string | null>(null)
  const supabase = createClient()

  useEffect(() => {
    async function fetchUser() {
      try {
        const {
          data: { session },
          error,
        } = await supabase.auth.getSession()
        if (error) throw error

        if (session) {
          setSession(session)
          setUser(session.user)
          const decodedJwt = jwtDecode<SupabaseJwtPayload>(session.access_token)
          setRole(decodedJwt.app_metadata.role)
        }
      } catch (error) {
        setError(error as AuthError)
      } finally {
        setLoading(false)
      }
    }
    fetchUser()
  }, [])

  return { loading, error, session, user, role }
}
```

Need explanation

#### Server page

Create a file named `page.tsx` inside the `app/server` folder:

```tsx title="@/app/server/page.tsx"
import { getUserRole } from "@/lib/supabase/get-user-role-server"
import { createClient } from "@/lib/supabase/server"

export default async function ServerPage() {
  const supabase = createClient()
  const {
    data: { user },
  } = await supabase.auth.getUser()

  const role = await getUserRole()

  return (
    <div className="space-y-4">
      <h1 className="text-lg font-medium">User: {user?.email || "N/A"}</h1>
      <h2 className="text-lg font-medium"> Role: {role || "N/A"}</h2>
      <p className="text-muted-foreground">(I am a server component.)</p>
    </div>
  )
}
```

Explain

#### Protected page

Create a file named `page.tsx` inside the `app/protected` folder:

```tsx title="@/app/protected/page.tsx"
export default function ProtectedPage() {
  return <h1 className="text-lg font-medium">I am a protected component.</h1>
}
```

#### Admin page

Create a file named `page.tsx` inside the `app/admin` folder:

```tsx title="@/app/admin/page.tsx"
import { createClient } from "@/lib/supabase/server"

export default async function AdminPage() {
  const supabase = createClient()

  // Fetch all users from the public users table
  const { data: users, error } = await supabase
    .from("users")
    .select("id, email, role")

  return (
    <div className="space-y-4">
      <h1 className="text-lg font-medium">Welcome admin!</h1>
      <h2>User List:</h2>
      {error ? (
        <p>Error loading users: {error.message}</p>
      ) : (
        <ul className="text-muted-foreground text-sm">
          {users.map(({ id, email, role }) => (
            <li key={id}>
              Email: {email}, Role: {role}
            </li>
          ))}
        </ul>
      )}
    </div>
  )
}
```

Explain

#### Login page

Create a file named `page.tsx` inside the `app/login` folder:

```tsx title="@/app/login/page.tsx"
"use client"

import { useState } from "react"
import { useSearchParams } from "next/navigation"

import { createClient } from "@/lib/supabase/client"
import { Button } from "@/components/ui/button"
import { toast } from "@/components/ui/use-toast"
import { Icons } from "@/components/icons"

export default function LoginPage() {
  const [isGoogleLoading, setIsGoogleLoading] = useState<boolean>(false)
  const supabase = createClient()

  const searchParams = useSearchParams()

  const next = searchParams.get("next")

  async function signInWithGoogle() {
    setIsGoogleLoading(true)
    try {
      const { error } = await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: `${window.location.origin}/auth/callback${
            next ? `?next=${encodeURIComponent(next)}` : ""
          }`,
        },
      })

      if (error) {
        throw error
      }
    } catch (error) {
      toast({
        title: "Please try again.",
        description: "There was an error logging in with Google.",
        variant: "destructive",
      })
      setIsGoogleLoading(false)
    }
  }

  return (
    <Button
      type="button"
      variant="outline"
      onClick={signInWithGoogle}
      disabled={isGoogleLoading}
    >
      {isGoogleLoading ? (
        <Icons.loaderCircle className="mr-2 size-4 animate-spin" />
      ) : (
        <Icons.google className="mr-2 size-6" />
      )}{" "}
      Sign in with Google
    </Button>
  )
}
```

When a user clicks the `Sign in with Google` button, the following sequence of events occurs:

- The `signInWithGoogle` function is called, initiating the OAuth flow with Google.
- The user is redirected to Google's authentication page, where they sign in and grant necessary permissions.
- After successful authentication, Google redirects the user back to our application's `/auth/callback` route. Notice how we include the `next` parameter in this redirect URL, ensuring we don't lose context of where the user originally intended to go.

#### Auth callback route

To handle the OAuth callback, create a file named `route.ts` inside the `app/auth/callback` folder:

```ts title="@/app/auth/callback/route.ts"
import { NextResponse } from "next/server"

import { createClient } from "@/lib/supabase/server"

export async function GET(request: Request) {
  // Extract search parameters and origin from the request URL
  const { searchParams, origin } = new URL(request.url)

  // Get the authorization code and the 'next' redirect path
  const code = searchParams.get("code")
  const next = searchParams.get("next") ?? "/"

  if (code) {
    // Create a Supabase client
    const supabase = createClient()

    // Exchange the code for a session
    const { error } = await supabase.auth.exchangeCodeForSession(code)

    if (!error) {
      // If successful, redirect to the 'next' path or home
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  // If there's no code or an error occurred, redirect to an error page
  return NextResponse.redirect(`${origin}/auth/auth-code-error`)
}
```

After Google authenticates the user and redirects them back to our application's `/auth/callback` route, the following process occurs:

- The `GET` function handles the incoming request to the `/auth/callback` route.
- We extract the `code` (authorization code) sent by Google.
- We also retrieve the `next` parameter, which contains the path where the user should be redirected after successful authentication. If it's not present, we default to the root path ("/").
- If an authorization code is present, we create a Supabase client.
- We then use Supabase's `exchangeCodeForSession` method to exchange the authorization code for a user session. This step completes the OAuth flow, establishing the user's authenticated session in our application.
- If the code exchange is successful (no error), we redirect the user to the path specified in the `next` parameter, or the home page if no specific path was provided.
- If there's no authorization code, or if an error occurs during the code exchange, we redirect the user to an error page.

This callback handler ensures that after Google's authentication, we complete the process by establishing a session in our application and then direct the user to their intended destination.

</BlogPostLayout>
